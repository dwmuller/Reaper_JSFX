desc: Stereo Looper with MIDI control
// tags: processing MIDI sampler
// author: Dan Muller

// Inspired by Super8 and Moebius.

options: maxmem=8388608

in_pin: input 1
in_pin: input 2
out_pin: output 1
out_pin: output 2

slider1:param_midi_bus=1<1,16,1>MIDI bus
slider2:param_midi_channel=0<0,16,1{Any,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16}>MIDI channel

@init
// The @init section is executed when the effect is loaded, when
// the audio sample rate changes, or when Reaper starts playing.
//
// Looper playing is distinct from Reaper playing. The looper can
// play even when Reaper is stopped. However, when Reaper starts playing,
// all memory is zeroed and this section runs again.
//
// Functions defined in @init can be used by other sections.

ext_midi_bus = 1.0; // Enable Reaper MIDI bus support

// Audio processing states
_st_EMPTY = 1;
_st_PAUSED = 2;
_st_PLAYING = 3;
_st_RECORDING = 4;
engine_state = _st_EMPTY;

// Input events
_inp_PAUSE_TOGGLE   = 1; // Pause->Continue
_inp_RECORD_TOGGLE  = 2; // Record->Play
_inp_RESET          = 3; // Reset to empty
_inp_RESTART_TOGGLE = 4; // Pause->Restart
// g_user_event_count = 4;

// Internal events
_evt_LOOP_END = 20;      // Internal, never enqueued, immediate.

// TODO:
// Serialize configuration settings.
// Input control configuration (ugh)
// Quantizing
//   Quantize to loop is easy but only somewhat useful.
//   Better quantizing requires determining a beat and resolution.
//   Requires enqueuing events.
// Multiply recording
//   Record buffer size unknown, handle memory exhaustion dynamically.
//   Record len can exceed loop len, frame index modulo loop len -> remainder is
//   play frame index.
//   Needs a separate toggle event. Interaction with regular recording state?
//   Is this a new state, or a substate of recording?
//   Best to think of this as the default, single-loop recording special
//   substate. 
// Variable size layers
//   Store offset and len at start of each layer.
//   Layer sample retrieval more complex.
//   Recording start stores offset.
// Undo/redo
//   Discard redo buffs when new recording starts.
// Feedback/fadeout
//   Discarding faded-out layers is difficult - may have to treat layer
//   audio memory as circular? Leading layers can die while playing or
//   recording.
// Trim
//   AKA alternate form of multiply recording.
//   Need a new toggle event. Interaction with regular multiply?
//   Is this a new state, or a substate of multiply?
// Long-press actions, e.g. for reset.
//   Not clear how to do this. Need to recognize a MIDI command pair and timing
//   between them.



// Memory organization
//
// We can record multiple layers so that we can undo overdubs.
//
// The loop audio is a sequence of "layer" buffers. The last layer buffer is
// the recording buffer. Each layer buffer has some prefix data, followed by
// a sequence of frames. A frame is a sequence of samples, one for each 
// channel. The recording layer always takes up all remaining memory, and is
// truncated when saved.
//
mem_audio_start = 0;  // Start of loop audio buffer memory.
mem_audio_end = __memtop();

// The layer prefix consists of:
// - Count of the frames in the buffer.
// - Start, which is how many frames into the loop this layer was recorded.
// - Loop length, in frames, after this layer was saved.
_LAYER_PREFIX_SIZE = 3;

// Because this anemic language has no notion of arrays or other multi-value
// object, we have to build such in the general memory. We allocate that space
// at the beginning of memory.

// A buffer in which to compose the output of all layers for all channels.
mem_frame_buff = mem_audio_start;
mem_audio_start += num_ch;


// Map of MIDI commands to user-generated events. For ease of lookup, each
// MIDI channel voice command is stored as a status byte value (with zero
// channel), and a byte value. We never care about the possible third byte.
// The index into this array is the event number.
/*
g_user_event_map = mem_audio_start;
mem_audio_start += g_user_event_count*2;
*/

// Queue of pending events.
/*
g_event_queue = mem_audio_start;
g_event_queue_max_len = 16;
mem_audio_start += g_event_queue_max_len;
g_event_queue_len = 0;
*/

// Utilities
function is_running() (
    (engine_state != _st_EMPTY) && (engine_state != _st_PAUSED);
);
function debug_layer(layer) (
    this.layer = layer;
    this.len = this.layer[0];
    this.start = this.layer[1];
    this.loop_len = this.layer[2];
);

// Layer accessors
function get_next_layer(layer) (
    layer + floor((layer[0]*num_ch)+_LAYER_PREFIX_SIZE);
);
function get_layers_end() local(layer) (
    layer = layers_start;
    loop(layers_count, layer=get_next_layer(layer));
    layer;
);

// State transition action support
function try_start_recording() local(ptr) (
    ptr = get_layers_end();

    // Make sure we have room for at least the prefix.
    ((mem_audio_end - ptr) >= _LAYER_PREFIX_SIZE) ? (
        // Set up a layer prefix.
        ptr[0] = 0;
        ptr[1] = engine_frame_idx;
        ptr[2] = engine_loop_len;
        engine_recording_layer = ptr;
        // TODO: Overwrite undone, inactive layers_
        1;
    ) : (
        0; // return false, no memory!!
    );
);
function save_layer() local(frame_count) (
    // The recording buffer, which appears after the last layer buffer (if
    // any), becomes a layer buffer.
    // Returns false if there are no layers after trying to save.

    frame_count = engine_frame_idx - engine_recording_layer[1];

    frame_count ? (
        // If this will be the first layer, set the loop length
        // to its audio length.
        !layers_count ? (engine_loop_len = engine_frame_idx);

        engine_recording_layer[0] = frame_count;
        engine_recording_layer[2] = engine_loop_len;
        layers_count+=1;

        Debug.save_layer.debug_layer(engine_recording_layer); // DBG

        engine_recording_layer = -1; // No recording layer.
    );
    layers_count != 0;
);
function pause() (
    // Does nothing. Associated state change causes frame index to stop
    // incrementing.
    1;
);
function reset() (
    // Zero out anything that might have been touched. Caller should
    // make sure that we're not recording, we don't clear an
    // active recording layer.
    memset(layers_start, 0, get_layers_end()-layers_start);

    // Layer buffer management
    layers_start = mem_audio_start;
    layers_count = 0;  // Active (playable) layers_

    // Loop length and frame position management
    engine_loop_len = 0;  // In frames
    engine_frame_idx = 0; // Index of frame currently playing/recording.
);
function continue() (
    // Does nothing. Associated state change causes frame index to continue
    // incrementing.
    1;
);
function restart() (
    // Associated state change causes frame index to start incrementing.
    engine_frame_idx = 0;
    1;
);

reset();

// Given a current state and an event, possibly change states and perform
// actions. This function embodies the entire state machine of the looper's
// audio engine_
function handle_event(evt) (
/*
    Model for a new clause, with all events:
    (_st_? == engine_state) ? (
        (_inp_RECORD_TOGGLE == evt) ? (do() ? _st_RECORDING : engine_state) :
        (_inp_PAUSE_TOGGLE == evt) ? (do(); _st_PAUSED) :
        (_inp_RESTART_TOGGLE == evt) ? (do(); _st_PAUSED) :
        (_inp_RESET == evt) ? (reset(); _st_EMPTY) :
        (_evt_LOOP_END == evt) ? () :
        engine_state;
    ) :
*/
    engine_state = 
        (_st_EMPTY == engine_state) ? (
            (_inp_RECORD_TOGGLE == evt) ? (try_start_recording() ? _st_RECORDING : engine_state) :
            engine_state;
        ) :
        (_st_RECORDING == engine_state) ? (
            (_inp_RECORD_TOGGLE == evt) ? (
                save_layer() ? _st_PLAYING : _st_EMPTY) :
            (_inp_PAUSE_TOGGLE == evt) ? (
                save_layer() ? (pause(); _st_PAUSED;) : _st_EMPTY) :
            (_inp_RESTART_TOGGLE == evt) ? (
                save_layer() ? (pause(); _st_PAUSED;) : _st_EMPTY) :
            (_inp_RESET == evt) ? (save_layer(); reset(); _st_EMPTY;) :
            (_evt_LOOP_END == evt) ? (
                save_layer(); 
                // TODO: Notify of memory exhaustion.
                try_start_recording() ? _st_RECORDING : (pause(); _st_PAUSED)
            ) :
            engine_state;
        ) :
        (_st_PLAYING == engine_state) ? (
            (_inp_RECORD_TOGGLE == evt) ? (try_start_recording() ? _st_RECORDING : engine_state) :
            (_inp_PAUSE_TOGGLE == evt) ? (pause(); _st_PAUSED) :
            (_inp_RESTART_TOGGLE == evt) ? (pause(); _st_PAUSED) :
            (_inp_RESET == evt) ? (reset(); _st_EMPTY) :
            engine_state;
        ) :
        (_st_PAUSED == engine_state) ? (
            (_inp_RECORD_TOGGLE== evt) ? (try_start_recording() ? _st_RECORDING : engine_state) :
            (_inp_PAUSE_TOGGLE == evt) ? (continue(); _st_PLAYING;) :
            (_inp_RESTART_TOGGLE == evt) ? (restart(); _st_PLAYING;) :
            (_inp_RESET == evt) ? (reset(); _st_EMPTY;) :
            engine_state;
        ) : (
            // Unknown initial state. WTF?
            engine_state;
        );
);
function handle_input_event(evt) (
    Debug.last_evt = evt; // assists debugging
    handle_event(evt);
);

@serialize
1; // Need this section to be non-empty.

@slider
midi_bus = param_midi_bus-1; // sets system variable
midi_input_chan_idx = param_midi_channel-1; // Users see number, code uses index

@block
// Code in this section is executed when each block of samples is received
// from the input. Then, @sample is executed for each sample in the block.
// MIDI processing is typically done here, although it can also be done
// in @sample.


function handle_midi() local(offset,m1,m2,m3,chan_idx,status,value) (
    while (midirecv(offset,m1,m2,m3)) (
        (m1 >= 0x80) && (m1 < 0xF0) ? (
            // Examine a channel voice message
            chan_idx = m1 & 0x0F;
            status = m1 & 0xF0;
            value = m2;
            (-1 /* omni */ == midi_input_chan_idx || chan_idx == midi_input_chan_idx) ? (
                // We're either in OMNI mode or it's to our MIDI channel.

                // TODO: Stupid simple command recognition right now.
                // TODO: No quantization (or cmd queue growth)
                (status == 0xC0 /* PC */) ? handle_input_event(value+1);
            );
        );
        // We pass all MIDI messages through.
        midisend(offset,m1,m2,m3);
    );
);

// Process all MIDI commands, each of which consists of up to three bytes.
handle_midi();

@sample
// Code in this section gets executed once for each audio sample.
// Sample are spl(n), where n is the input channel index. They can be modified.
// num_ch is the number of channels - typically 2, left and right.

function try_append_layer_frame(frame) local(ptr) (
    ptr = engine_recording_layer + _LAYER_PREFIX_SIZE + engine_recording_layer[0]*num_ch;
    ((mem_audio_end - num_ch) > ptr) ? (
        memcpy(ptr, frame, num_ch);
        engine_recording_layer[0] += 1;
        1;
    ) : (
        0;
    );
);
function add_layer_frame(layer, frame) local(frame_idx, ptr, chan) (
    frame_idx = (engine_frame_idx % layer[2]) - layer[1];
    (frame_idx >= 0 && frame_idx < layer[0]) ? (
        ptr = layer + _LAYER_PREFIX_SIZE + (frame_idx*num_ch);
        chan = 0;
        loop(num_ch, frame[chan] += ptr[chan]; chan+=1);
    );
);
function get_layers_frame(frame) local(layer) (
    // Add the current samples from each layer to the output.
    layer = layers_start;
    loop(layers_count,
        add_layer_frame(layer, frame);
        layer = get_next_layer(layer);
    );
);
function rcv_frame(frame) local(chan) (
    chan = 0;
    loop(num_ch, frame[chan] = spl(chan); chan += 1);
);
function send_frame(frame) local(chan) (
    chan = 0;
    loop(num_ch, spl(chan) = frame[chan]; chan += 1);
);
function clear_frame(frame) (
    memset(frame, 0, num_ch);
);

// TODO: Need a specific event for memory exhaustion.
(_st_RECORDING == engine_state) ? (
    rcv_frame(mem_frame_buff);
    !try_append_layer_frame(mem_frame_buff) ? 
        handle_input_event(_inp_PAUSE_TOGGLE);
);

// If we allowed monitoring, we'd skip this.
clear_frame(mem_frame_buff);

is_running() ? get_layers_frame(mem_frame_buff);

send_frame(mem_frame_buff);

is_running() ? (
    // Increment the frame index on every @sample call if we're not
    // stopped. If we've reached the end of the loop, signal loop end
    // and wrap.
    engine_frame_idx += 1;
    (layers_count && (engine_frame_idx >= engine_loop_len)) ? (
        engine_frame_idx = 0;
        handle_event(_evt_LOOP_END);
    );
);

